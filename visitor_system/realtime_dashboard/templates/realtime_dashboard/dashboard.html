{% extends 'base.html' %}
{% load static %}

{% block title %}Дашборд в реальном времени{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.css">
<style>
.dashboard-grid {
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: 20px;
    padding: 20px;
}

.widget {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 20px;
    transition: transform 0.2s, box-shadow 0.2s;
}

.widget:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.15);
}

.widget-header {
    display: flex;
    justify-content: between;
    align-items: center;
    margin-bottom: 15px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.widget-title {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    margin: 0;
}

.widget-refresh {
    color: #666;
    cursor: pointer;
    font-size: 14px;
}

.widget-refresh:hover {
    color: #007bff;
}

.counter-widget {
    text-align: center;
}

.counter-value {
    font-size: 48px;
    font-weight: bold;
    margin: 15px 0;
}

.counter-label {
    font-size: 14px;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.counter-change {
    font-size: 12px;
    margin-top: 5px;
}

.counter-change.positive {
    color: #28a745;
}

.counter-change.negative {
    color: #dc3545;
}

.chart-widget {
    height: 300px;
}

.activity-feed {
    max-height: 400px;
    overflow-y: auto;
}

.activity-item {
    display: flex;
    align-items: flex-start;
    padding: 10px 0;
    border-bottom: 1px solid #f0f0f0;
}

.activity-item:last-child {
    border-bottom: none;
}

.activity-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 12px;
    font-size: 14px;
    color: white;
}

.activity-icon.visit-created { background: #007bff; }
.activity-icon.visit-checked-in { background: #28a745; }
.activity-icon.visit-checked-out { background: #6c757d; }
.activity-icon.security-alert { background: #dc3545; }

.activity-content {
    flex: 1;
}

.activity-title {
    font-weight: 600;
    margin-bottom: 2px;
}

.activity-message {
    font-size: 13px;
    color: #666;
    margin-bottom: 2px;
}

.activity-time {
    font-size: 11px;
    color: #999;
}

.table-widget {
    overflow-x: auto;
}

.table-widget table {
    width: 100%;
    border-collapse: collapse;
}

.table-widget th,
.table-widget td {
    text-align: left;
    padding: 8px 12px;
    border-bottom: 1px solid #eee;
}

.table-widget th {
    background: #f8f9fa;
    font-weight: 600;
    font-size: 12px;
    text-transform: uppercase;
    color: #666;
}

.status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 6px;
}

.status-active { background: #28a745; }
.status-pending { background: #ffc107; }
.status-inactive { background: #6c757d; }

.refresh-indicator {
    display: inline-block;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.color-blue { color: #007bff; }
.color-green { color: #28a745; }
.color-orange { color: #fd7e14; }
.color-purple { color: #6f42c1; }
.color-red { color: #dc3545; }

.grid-w-3 { grid-column: span 3; }
.grid-w-4 { grid-column: span 4; }
.grid-w-6 { grid-column: span 6; }
.grid-w-8 { grid-column: span 8; }
.grid-w-12 { grid-column: span 12; }

.grid-h-2 { grid-row: span 2; }
.grid-h-3 { grid-row: span 3; }
.grid-h-4 { grid-row: span 4; }

@media (max-width: 768px) {
    .dashboard-grid {
        grid-template-columns: 1fr;
        padding: 10px;
    }
    
    .widget {
        grid-column: span 1 !important;
    }
}

/* Toasts */
.toast-container { position: fixed; top: 16px; right: 16px; z-index: 1060; display: flex; flex-direction: column; gap: 8px; }
.toast { background: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 14px; min-width: 260px; border-left: 4px solid #206bc4; }
.toast.success { border-color: #28a745; }
.toast.warning { border-color: #ffc107; }
.toast.danger { border-color: #dc3545; }
.toast .title { font-weight: 600; margin-bottom: 4px; }
.toast .msg { font-size: 13px; color: #555; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div id="toast-root" class="toast-container"></div>
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1 class="h3">
                    <i class="fas fa-tachometer-alt me-2"></i>
                    Дашборд в реальном времени
                </h1>
                <div class="d-flex align-items-center gap-2">
                    <select id="filter-department" class="form-select form-select-sm" style="width:auto;">
                        <option value="">Все департаменты</option>
                    </select>
                    <select id="filter-period" class="form-select form-select-sm" style="width:auto;">
                        <option value="24h">Последние 24 часа</option>
                        <option value="today">Сегодня</option>
                        <option value="7d">7 дней</option>
                        <option value="30d">30 дней</option>
                    </select>
                    <button class="btn btn-outline-secondary btn-sm" id="btn-export-csv">
                        <i class="fas fa-file-csv me-1"></i>
                        Экспорт CSV
                    </button>
                    <span class="badge bg-success me-2" id="connection-status">
                        <i class="fas fa-wifi me-1"></i>
                        Подключено
                    </span>
                    <button class="btn btn-outline-primary btn-sm" id="refresh-all-btn">
                        <i class="fas fa-sync-alt me-1"></i>
                        Обновить все
                    </button>
                </div>
            </div>
            
            {% if has_new_widgets %}
            <div class="alert alert-info alert-dismissible fade show mb-4" role="alert">
                <strong>Внимание!</strong> Добавлены новые виджеты. Если они не отображаются, 
                <a href="?update_widgets=1&clear_cache=1" class="alert-link">нажмите сюда</a> для обновления дашборда.
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
            {% endif %}
            
            {% if debug_mode %}
                {% include "realtime_dashboard/debug_panel.html" %}
            {% endif %}
        </div>
    </div>
    
    <div class="dashboard-grid" id="dashboard-grid">
        {% for widget in widgets %}
        <div class="widget grid-w-{{ widget.width }} grid-h-{{ widget.height }}" 
             data-widget-id="{{ widget.id }}" 
             data-widget-type="{{ widget.widget_type }}"
             data-refresh-interval="{{ widget.refresh_interval }}"
             data-metric="{{ widget.config.metric|default:'' }}">
            
            <div class="widget-header">
                <h5 class="widget-title">{{ widget.title }}</h5>
                <span class="widget-refresh" data-widget-id="{{ widget.id }}">
                    <i class="fas fa-sync-alt"></i>
                </span>
            </div>
            
            <div class="widget-content" id="widget-content-{{ widget.id }}">
                <div class="py-3" aria-hidden="true">
                    <div class="skeleton skel-rect"></div>
                    <div class="skel-line lg"></div>
                    <div class="skel-line"></div>
                    <div class="skel-line sm"></div>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<!-- Fixed Chart.js loading with fallback -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script>
// Check if Chart.js loaded correctly and load a fallback if not
if (typeof Chart === 'undefined') {
    console.warn('Chart.js failed to load from primary CDN, trying fallback...');
    var chartScript = document.createElement('script');
    chartScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js';
    chartScript.onload = function() {
        console.log('Chart.js fallback loaded successfully');
        chartReady = true;
        if (typeof refreshAllWidgets === 'function') {
            setTimeout(refreshAllWidgets, 500);
        }
    };
    document.head.appendChild(chartScript);
}
</script>
<script>
// НАЧАЛО ОТЛАДКИ - этот лог должен быть виден в консоли сразу же
console.log('=== DASHBOARD SCRIPT START ===');
console.log('Script loading time:', new Date().toISOString());

// Глобальные перехватчики ошибок для диагностики
window.addEventListener('error', function (e) {
    try {
        console.error('Global JS error:', e.error || e.message || e);
    } catch (_) {}
});
window.addEventListener('unhandledrejection', function (e) {
    try {
        console.error('Unhandled promise rejection:', e.reason || e);
    } catch (_) {}
});

// Глобальные переменные
console.log('=== DECLARING GLOBAL VARIABLES ===');
let charts = {};
let refreshIntervals = {};
let isRefreshing = false;
let chartReady = typeof Chart !== 'undefined';
console.log('chartReady:', chartReady, 'Chart available:', typeof Chart !== 'undefined');
// Храним предыдущее состояние метрик на уровне виджета, чтобы
// одинаковые метрики в разных виджетах не блокировали рендер
window.__lastMetricStateByWidget = window.__lastMetricStateByWidget || {};
console.log('Global variables declared successfully');

// Ручной тестовый триггер для загрузки данных
window.triggerDashboardTest = function () {
    console.log('Manual dashboard test: triggering meta refresh');
    try {
        const dep = (document.body && document.body.dataset && document.body.dataset.filterDepartment) || '';
        const period = (document.body && document.body.dataset && document.body.dataset.filterPeriod) || '';
        if (typeof refreshAllWidgetsWithMeta === 'function') {
            refreshAllWidgetsWithMeta(dep, period);
        } else {
            console.warn('refreshAllWidgetsWithMeta not ready yet; scheduling retry');
            setTimeout(() => {
                if (typeof refreshAllWidgetsWithMeta === 'function') {
                    refreshAllWidgetsWithMeta(dep, period);
                } else {
                    console.error('refreshAllWidgetsWithMeta still not available');
                }
            }, 1000);
        }
    } catch (e) {
        console.error('Manual test failed:', e);
    }
};

// Ожидатель готовности функций дашборда
function waitForDashboardFunctions(callback, attempt = 0) {
    const maxAttempts = 20; // ~10 сек при шаге 500мс
    const ready = (
        typeof initializeDashboard === 'function' &&
        typeof setupAutoRefresh === 'function' &&
        typeof refreshAllWidgetsWithMeta === 'function'
    );
    if (ready) {
        try { callback(); } catch (e) { console.error('waitForDashboardFunctions callback failed:', e); }
        return;
    }
    if (attempt >= maxAttempts) {
        console.error('Dashboard functions did not become ready in time');
        return;
    }
    setTimeout(() => waitForDashboardFunctions(callback, attempt + 1), 500);
}

// Объявляем функцию refreshAllWidgets в глобальной области
window.refreshAllWidgets = function() {
    console.log('refreshAllWidgets called, isRefreshing:', isRefreshing);
    
    if (isRefreshing) return;
    
    isRefreshing = true;
    const widgets = document.querySelectorAll('.widget');
    
    console.log('Found widgets:', widgets.length);
    
    widgets.forEach(widget => {
        const widgetId = widget.dataset.widgetId;
        const last = widget.getAttribute('data-last-ts');
        // Лёгкий diff: для counters/activity/table всегда обновляем; для charts — только если timestamp изменился
        const widgetType = widget.dataset.widgetType;
        const critical = widgetType === 'counter' || widgetType === 'table' || widgetType === 'activity_feed';
        if (critical) {
            console.log('Refreshing widget (critical):', widgetId);
            refreshWidget(widgetId);
        } else {
            console.log('Refreshing widget (chart):', widgetId);
            refreshWidget(widgetId);
        }
    });
    
    setTimeout(() => {
        isRefreshing = false;
        console.log('Refresh completed');
    }, 2000);
}

// Делаем функцию доступной глобально
window.refreshAllWidgets = refreshAllWidgets;

// Инициализация дашборда
document.addEventListener('DOMContentLoaded', function() {
    console.log('=== DOM CONTENT LOADED EVENT FIRED ===');
    console.log('DOM loaded, initializing dashboard...');
    console.log('Current timestamp:', new Date().toISOString());
    console.log('Chart.js status:', typeof Chart !== 'undefined');
    
    // Проверяем доступность Chart.js
    if (typeof Chart === 'undefined') {
        console.warn('Chart.js не загружен! Пробуем динамическую подгрузку...');
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
        s.onload = () => {
            chartReady = true;
            console.log('Chart.js loaded dynamically');
            setTimeout(() => {
                try { 
                    console.log('Attempting refresh after Chart.js load');
                    refreshAllWidgets(); 
                } catch (e) { 
                    console.warn('Refresh after chart load failed', e); 
                    // Fallback to meta refresh
                    try {
                        const dep = document.body.dataset.filterDepartment || '';
                        const period = document.body.dataset.filterPeriod || '';
                        refreshAllWidgetsWithMeta(dep, period);
                    } catch (e2) {
                        console.error('Meta refresh failed too', e2);
                    }
                }
            }, 500); // Delay to ensure Chart.js is fully initialized
        };
        s.onerror = () => {
            console.error('Dynamic Chart.js load failed');
            // Even if Chart.js fails, try to load non-chart widgets
            setTimeout(() => {
                document.querySelectorAll('.widget').forEach(widget => {
                    const type = widget.dataset.widgetType;
                    if (type !== 'chart_line' && type !== 'chart_pie' && type !== 'chart_bar') {
                        refreshWidget(widget.dataset.widgetId);
                    }
                });
            }, 500);
        };
        document.head.appendChild(s);
    } else {
        chartReady = true;
        console.log('Chart.js загружен успешно');
    }
    // Отключаем ServiceWorker для дашборда (dev) во избежание кеш-конфликтов
    if (navigator.serviceWorker && navigator.serviceWorker.getRegistrations) {
        navigator.serviceWorker.getRegistrations().then(regs => {
            regs.forEach(r => r.unregister());
            console.log('ServiceWorker unregistered for dashboard');
        }).catch(() => {});
    }
    
    // Удаляем возможные устаревшие inline-обработчики (если отдали кешированную версию)
    try {
        const btn = document.getElementById('refresh-all-btn');
        if (btn && btn.hasAttribute('onclick')) {
            btn.removeAttribute('onclick');
            console.log('Removed inline onclick from refresh-all-btn');
        }
        document.querySelectorAll('.widget-refresh[onclick]').forEach(el => {
            el.removeAttribute('onclick');
        });
    } catch (e) { console.warn('Cleanup onclick failed', e); }

    // Основная инициализация с ожиданием готовности функций
    waitForDashboardFunctions(() => {
        console.log('Dashboard functions ready; running init');
        try { initializeDashboard(); } catch (e) { console.error('initializeDashboard failed:', e); }
        try { setupAutoRefresh(); } catch (e) { console.error('setupAutoRefresh failed:', e); }
    });
    
    // ПРИНУДИТЕЛЬНАЯ ЗАГРУЗКА ДАННЫХ - ДОБАВЛЕНО ДЛЯ ОТЛАДКИ
    console.log('=== FORCING DATA LOAD ===');
    setTimeout(() => {
        console.log('Executing forced data refresh...');
        waitForDashboardFunctions(() => {
            const dep = document.body.dataset.filterDepartment || '';
            const period = document.body.dataset.filterPeriod || '';
            refreshAllWidgetsWithMeta(dep, period);
        });
    }, 1500);

    // Дополнительный дубль-резерв на случай блокировок
    setTimeout(() => {
        console.log('Executing backup forced data refresh...');
        waitForDashboardFunctions(() => {
            try {
                const dep = document.body.dataset.filterDepartment || '';
                const period = document.body.dataset.filterPeriod || '';
                refreshAllWidgetsWithMeta(dep, period);
            } catch (e) {
                console.error('Backup forced refresh failed:', e);
            }
        });
    }, 4000);

    // WebSocket подключения для живых обновлений
    try {
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${wsScheme}://${window.location.host}/ws/dashboard/`;
        console.log('Connecting WS:', wsUrl);
        const socket = new WebSocket(wsUrl);

        socket.onopen = () => console.log('WS connected');
        socket.onclose = (e) => {
            console.warn('WS disconnected', e && (e.code + ':' + e.reason));
            // При проблемах с WS — подстраховка: жёсткая перезагрузка данных
            try { window.triggerDashboardTest(); } catch(_) {}
        };
        socket.onerror = (e) => console.error('WS error', e);
        socket.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                console.log('WS message:', message);

                if (message.type === 'metrics' && message.data) {
                    showToast('Обновление данных', 'Поступили новые метрики', 'success');
                    refreshAllWidgets();
                }

                if (message.type === 'event') {
                    const ev = message.data || {};
                    showToast(ev.title || 'Событие', ev.message || '', ev.priority === 'high' ? 'danger' : 'info');
                    // Обновляем только события и активные визиты
                    document.querySelectorAll('.widget').forEach(w => {
                        const type = w.dataset.widgetType;
                        if (type === 'activity_feed' || type === 'table' || type === 'counter') {
                            refreshWidget(w.dataset.widgetId);
                        }
                    });
                }
            } catch (err) {
                console.error('WS parse error:', err);
            }
        };
    } catch (e) {
        console.error('WS init failed', e);
    }
    
    // Тестируем доступность функции refreshAllWidgets и навешиваем обработчик на кнопку
    console.log('Testing refreshAllWidgets function:', typeof window.refreshAllWidgets);
    console.log('Function available:', typeof refreshAllWidgets);
    const refreshBtn = document.getElementById('refresh-all-btn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', function(e) {
            e.preventDefault();
            try { refreshAllWidgets(); } catch (err) { console.error('refreshAllWidgets error:', err); }
        });
    }

    // Экспорт CSV активных визитов
    const exportBtn = document.getElementById('btn-export-csv');
    if (exportBtn) {
        exportBtn.addEventListener('click', async function(e){
            e.preventDefault();
            try {
                const dep = document.body.dataset.filterDepartment || '';
                const period = document.body.dataset.filterPeriod || '';
                const qs = new URLSearchParams();
                if (dep) qs.set('department_id', dep);
                if (period) qs.set('period', period);
                // Кодировка по умолчанию: windows-1251. Параметр encoding не передаем
                const url = `/dashboard/api/active_visits.csv${qs.toString()?`?${qs.toString()}`:''}`;

                exportBtn.disabled = true;
                const originalHtml = exportBtn.innerHTML;
                exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Экспорт...';

                const resp = await fetch(url, { credentials: 'same-origin', cache: 'no-store' });
                if (!resp.ok) throw new Error('HTTP ' + resp.status);

                const blob = await resp.blob();
                // Пытаемся извлечь имя файла из заголовка
                let filename = 'active_visits.csv';
                const cd = resp.headers.get('Content-Disposition') || '';
                const match = cd.match(/filename="?([^";]+)"?/i);
                if (match && match[1]) filename = match[1];

                const urlObj = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = urlObj;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(urlObj);

                if (typeof showToast === 'function') {
                    showToast('Экспорт', 'Файл CSV сформирован', 'success');
                }
                exportBtn.innerHTML = originalHtml;
                exportBtn.disabled = false;
            } catch (err) {
                console.error('Export failed', err);
                if (typeof showToast === 'function') {
                    showToast('Экспорт', 'Ошибка при экспорте CSV', 'danger');
                }
                exportBtn.disabled = false;
            }
        });
    }

    // Инициализация фильтров
    initFilters();
    // Пресеты отключены

    // Навешиваем обработчики на иконки обновления в заголовках виджетов
    document.querySelectorAll('.widget-refresh').forEach(el => {
        const id = el.getAttribute('data-widget-id');
        el.addEventListener('click', function(ev) {
            ev.preventDefault();
            if (id) {
                try { refreshWidget(id); } catch (err) { console.error('refreshWidget error:', err); }
            }
        });
    });
});
function initFilters() {
    const depSelect = document.getElementById('filter-department');
    const periodSelect = document.getElementById('filter-period');
    if (!depSelect || !periodSelect) return;
    // Восстановить сохранённые фильтры
    try {
        const saved = JSON.parse(localStorage.getItem('dashboardFilters') || '{}');
        if (saved && saved.period) periodSelect.value = saved.period;
        if (saved && saved.department_id) depSelect.value = saved.department_id;
        document.body.dataset.filterDepartment = saved.department_id || '';
        document.body.dataset.filterPeriod = saved.period || '';
    } catch {}
    // Первичное заполнение департаментов из общего запроса
    console.log('Загрузка департаментов из API...');
    loadDepartments();
    
    const apply = () => {
        const dep = depSelect.value;
        const period = periodSelect.value;
        document.body.dataset.filterDepartment = dep;
        document.body.dataset.filterPeriod = period;
        try { localStorage.setItem('dashboardFilters', JSON.stringify({ department_id: dep, period })); } catch {}
        refreshAllWidgetsWithMeta(dep, period);
    };
    depSelect.addEventListener('change', apply);
    periodSelect.addEventListener('change', apply);
}

function loadDepartments(retryCount = 3) {
    const depSelect = document.getElementById('filter-department');
    if (!depSelect) return;
    
    console.log(`Attempting to load departments (retry=${retryCount})`);
    
    fetch(`/dashboard/api/metrics/`, { 
        credentials: 'same-origin', 
        cache: 'no-store',
        headers: { 'Accept': 'application/json' }
    })
    .then(r => {
        if (!r.ok) {
            console.error(`Ошибка загрузки департаментов: HTTP ${r.status}`);
            throw new Error(`HTTP ${r.status}`);
        }
        return r.json();
    })
    .then(meta => {
        console.log('Получены данные о департаментах:', meta);
        if (!meta || !meta.success || !meta.data) {
            console.error('Некорректный формат данных департаментов:', meta);
            throw new Error('Некорректный формат данных');
        }
        
        const stats = meta?.data?.department_stats || [];
        if (!Array.isArray(stats) || stats.length === 0) {
            console.warn('Список департаментов пуст:', stats);
            if (retryCount > 0) {
                console.log(`Список департаментов пуст, повторная попытка через 2 секунды (осталось ${retryCount})...`);
                setTimeout(() => loadDepartments(retryCount - 1), 2000);
                return;
            }
        }
        
        // Очищаем кроме первой опции "Все департаменты"
        Array.from(depSelect.options).slice(1).forEach(o => o.remove());
        stats.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.department_id || '';
            opt.textContent = s.department;
            depSelect.appendChild(opt);
        });
        // Применим сохранённый департамент
        try {
            const saved = JSON.parse(localStorage.getItem('dashboardFilters') || '{}');
            if (saved && saved.department_id) depSelect.value = saved.department_id;
        } catch {}
        
        console.log('Департаменты успешно загружены и добавлены в select:', stats.length);
        
        // Если загрузка прошла успешно, обновим виджеты
        const dep = depSelect.value;
        const period = document.getElementById('filter-period')?.value || '24h';
        
        // Force refresh of all widgets with the department data
        setTimeout(() => {
            console.log('Triggering widget refresh with department data');
            refreshAllWidgetsWithMeta(dep, period);
            
            // Check for failed widgets after a short delay and retry them
            setTimeout(() => {
                const failedWidgets = document.querySelectorAll('.widget[data-render-failed="1"]');
                if (failedWidgets.length > 0) {
                    console.log(`Found ${failedWidgets.length} failed widgets, retrying...`);
                    failedWidgets.forEach(widget => {
                        const widgetId = widget.dataset.widgetId;
                        if (widgetId) {
                            refreshWidget(widgetId);
                        }
                    });
                }
            }, 2000);
        }, 500);
    })
    .catch(err => {
        console.error('Ошибка при загрузке департаментов:', err);
        if (retryCount > 0) {
            console.log(`Повторная попытка загрузки департаментов (осталось ${retryCount})...`);
            setTimeout(() => loadDepartments(retryCount - 1), 3000);
        } else {
            showToast('Ошибка', 'Не удалось загрузить список департаментов. Попробуйте обновить страницу.', 'danger');
        }
    });

function refreshAllWidgetsWithMeta(dep, period) {
    console.log('refreshAllWidgetsWithMeta invoked with:', { dep, period });
    const qs = new URLSearchParams();
    if (dep) qs.set('department_id', dep);
    if (period) qs.set('period', period);
    
    const url = `/dashboard/api/metrics/${qs.toString() ? `?${qs.toString()}` : ''}`;
    console.log('Fetching metrics data from:', url);
    
    fetch(url, {
        credentials: 'same-origin',
        cache: 'no-store',
        headers: { 'Accept': 'application/json' }
    })
    .then(r => {
        console.log('Metrics API response status:', r.status);
        if (!r.ok) {
            console.error(`Error fetching metrics: HTTP ${r.status}`);
            return Promise.reject(r.status);
        }
        return r.json();
    })
    .then(meta => {
        console.log('Metrics API response data:', meta);
        
        if (!meta || !meta.success || !meta.data) {
            console.error('Invalid metrics data format:', meta);
            // Если мета не пришла — делаем per-widget фолбэк
            document.querySelectorAll('.widget').forEach(w => refreshWidget(w.dataset.widgetId));
            return;
        }
        const ts = meta.data.timestamp || meta.timestamp || new Date().toISOString();
        console.log('Found widgets:', document.querySelectorAll('.widget').length);
        
    const allWidgets = document.querySelectorAll('.widget');
    console.log('Found widgets count:', allWidgets.length);
    allWidgets.forEach(widget => {
            const widgetId = widget.dataset.widgetId;
            const metric = widget.dataset.metric;
            const widgetType = widget.dataset.widgetType;
            const newData = metric ? meta.data[metric] : null;
            
            console.log(`Processing widget ${widgetId} (type: ${widgetType}, metric: ${metric}):`, newData);

            // Если нужной метрики нет в ответе, делаем фолбэк на per-widget API
            if (metric && typeof newData === 'undefined') {
                console.log(`No data for metric ${metric}, using fallback for widget ${widgetId}`);
                refreshWidget(widgetId);
                return;
            }

            const key = `${widgetId}::${metric || 'nometric'}`;
            const newStr = JSON.stringify(newData);
            const prevStr = window.__lastMetricStateByWidget[key];

            const isInitialized = widget.getAttribute('data-initialized') === '1';
            console.log(`Widget ${widgetId} - initialized: ${isInitialized}, data changed: ${prevStr !== newStr}`);
            
            if (!isInitialized || prevStr !== newStr) {
                window.__lastMetricStateByWidget[key] = newStr;
                const payload = {
                    widget_type: widget.dataset.widgetType,
                    data: newData,
                    config: { metric },
                    timestamp: ts
                };
                console.log(`Rendering widget ${widgetId} with payload:`, payload);
                try {
                    renderWidget(widgetId, payload);
                } catch (e) {
                    console.error(`renderWidget failed for ${widgetId}`, e);
                }
                widget.setAttribute('data-initialized', '1');
            } else {
                console.log(`Widget ${widgetId} skipped - no changes`);
            }
        });
    })
    .catch(err => {
        console.error('refreshAllWidgetsWithMeta failed', err);
        // Сеть/ошибка — фолбэк: перерисовать из per-widget API
        try {
            document.querySelectorAll('.widget').forEach(w => {
                try { refreshWidget(w.dataset.widgetId); } catch(e) { console.error('refreshWidget fallback failed', e); }
            });
        } catch (_) {}
    });
}

function initializeDashboard() {
    console.log('=== ИНИЦИАЛИЗАЦИЯ ДАШБОРДА ===');
    console.log('Инициализация дашборда...');
    
    // Первичная загрузка: тянем общие метрики и рендерим все виджеты одним запросом
    const dep = document.body.dataset.filterDepartment || '';
    const period = document.body.dataset.filterPeriod || '';
    console.log('Calling refreshAllWidgetsWithMeta with dep:', dep, 'period:', period);
    refreshAllWidgetsWithMeta(dep, period);
}

function setupAutoRefresh() {
    const widgets = document.querySelectorAll('.widget');
    
    // Вместо множества запросов — один общий
    const refreshInterval = 30000;
    setInterval(() => {
        if (!isRefreshing) {
            const dep = document.body.dataset.filterDepartment || '';
            const period = document.body.dataset.filterPeriod || '';
            console.log('Global auto-refresh (meta)');
            refreshAllWidgetsWithMeta(dep, period);
        }
    }, refreshInterval);
}


function refreshWidget(widgetId) {
    const widget = document.querySelector(`[data-widget-id="${widgetId}"]`);
    const content = document.getElementById(`widget-content-${widgetId}`);
    if (!widget || !content) {
        console.warn('Widget DOM not found for id', widgetId);
        return;
    }
    
    // Показываем индикатор загрузки
    const refreshIcon = widget.querySelector('.widget-refresh i');
    if (refreshIcon) refreshIcon.classList.add('refresh-indicator');
    
    const dep = document.body.dataset.filterDepartment || '';
    const period = document.body.dataset.filterPeriod || '';
    const qs = new URLSearchParams();
    if (dep) qs.set('department_id', dep);
    if (period) qs.set('period', period);
    
    const url = `/dashboard/api/widgets/${widgetId}/data/${qs.toString() ? `?${qs.toString()}` : ''}`;
    console.log(`Fetching widget data for ${widgetId} from: ${url}, widget type: ${widget.dataset.widgetType}, metric: ${widget.dataset.metric || 'unknown'}`);
    
    // Debug the widget data
    console.log(`Widget details:`, {
        id: widgetId,
        type: widget.dataset.widgetType,
        metric: widget.dataset.metric,
        initialized: widget.getAttribute('data-initialized')
    });
    
    fetch(url, {
        method: 'GET',
        credentials: 'same-origin',
        headers: { 'Accept': 'application/json' },
        cache: 'no-store'
    })
        .then(response => {
            console.log(`Widget ${widgetId} API response status:`, response.status);
            if (!response.ok) {
                console.error(`Ошибка HTTP ${response.status} при загрузке виджета ${widgetId}`);
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log(`Widget ${widgetId} API response data:`, data);
            if (data.success) {
                renderWidget(widgetId, data.data);
            } else {
                console.error(`Ошибка в ответе API для виджета ${widgetId}:`, data.error);
                showWidgetError(content, data.error || 'Ошибка загрузки данных');
            }
        })
        .catch(error => {
            console.error(`Ошибка загрузки виджета ${widgetId}:`, error);
            // Фолбэк: пробуем получить общие метрики и собрать данные для виджета локально
            const metricName = widget.getAttribute('data-metric');
            if (!metricName) {
                showWidgetError(content, 'Ошибка загрузки данных');
                return;
            }
            
            console.log(`Попытка фолбэк-загрузки для виджета ${widgetId} (метрика ${metricName})`);
            
            fetch(`/dashboard/api/metrics/`, {
                method: 'GET',
                credentials: 'same-origin',
                headers: { 'Accept': 'application/json' },
                cache: 'no-store'
            })
            .then(r => {
                if (!r.ok) {
                    console.error(`Ошибка HTTP ${r.status} при загрузке метрик`);
                    throw new Error(`HTTP ${r.status}`);
                }
                return r.json();
            })
            .then(meta => {
                if (meta.success && meta.data && meta.data[metricName] !== undefined) {
                    const fallback = {
                        widget_type: widget.dataset.widgetType,
                        data: meta.data[metricName],
                        config: { metric: metricName },
                        timestamp: meta.data.timestamp || new Date().toISOString()
                    };
                    console.log('Fallback render for widget', widgetId, 'metric', metricName, fallback);
                    renderWidget(widgetId, fallback);
                } else {
                    console.error('Fallback failed: no metric data found', metricName);
                    showWidgetError(content, 'Данные недоступны');
                }
            })
            .catch(e2 => {
                console.error('Fallback metrics load failed', e2);
                showWidgetError(content, 'Ошибка загрузки данных');
            });
        })
        .finally(() => {
            if (refreshIcon) refreshIcon.classList.remove('refresh-indicator');
        });
}

// Экспортируем функцию в глобальную область
window.refreshWidget = refreshWidget;
}

function renderWidget(widgetId, data) {
    console.log(`renderWidget called for ${widgetId}:`, data);
    const widget = document.querySelector(`[data-widget-id="${widgetId}"]`);
    const content = document.getElementById(`widget-content-${widgetId}`);
    const widgetType = widget?.dataset?.widgetType;
    
    console.log(`Widget DOM elements - widget: ${!!widget}, content: ${!!content}, type: ${widgetType}`);
    
    if (!widget || !content) {
        console.error(`Widget DOM not found: widgetId=${widgetId}, widget=${widget}, content=${content}`);
        return;
    }
    
    if (data && data.timestamp) {
        widget.setAttribute('data-last-ts', data.timestamp);
    }
    
    // Store the metric name in the widget data attribute for future reference
    if (data?.config?.metric) {
        widget.dataset.metric = data.config.metric;
    }
    
    // Добавляем отладочную информацию
    console.log(`Rendering widget ${widgetId} (${widgetType}):`, data);
    
    try {
        switch (widgetType) {
            case 'counter':
                console.log(`Rendering counter widget ${widgetId}`);
                renderCounterWidget(content, data);
                break;
            case 'chart_line':
                console.log(`Rendering line chart widget ${widgetId}`);
                renderLineChartWidget(widgetId, content, data);
                break;
            case 'chart_pie':
                console.log(`Rendering pie chart widget ${widgetId}`);
                renderPieChartWidget(widgetId, content, data);
                break;
            case 'chart_bar':
                console.log(`Rendering bar chart widget ${widgetId}`);
                renderBarChartWidget(widgetId, content, data);
                break;
            case 'activity_feed':
                console.log(`Rendering activity feed widget ${widgetId}`);
                renderActivityFeedWidget(content, data);
                break;
            case 'table':
                console.log(`Rendering table widget ${widgetId}`);
                renderTableWidget(content, data);
                break;
            default:
                console.warn(`Неподдерживаемый тип виджета: ${widgetType}`);
                content.innerHTML = `<p class="text-muted">Неподдерживаемый тип виджета: ${widgetType}</p>`;
        }
        
        // Mark widget as successfully initialized
        widget.setAttribute('data-initialized', '1');
        console.log(`Widget ${widgetId} successfully rendered and marked as initialized`);
        
    } catch (error) {
        console.error(`Error rendering widget ${widgetId} (${widgetType}):`, error);
        showWidgetError(content, `Ошибка рендеринга: ${error.message || 'Неизвестная ошибка'}`);
        
        // Mark as failed for potential retry
        widget.setAttribute('data-render-failed', '1');
    }
}

function renderBarChartWidget(widgetId, content, data) {
    const canvasId = `chart-${widgetId}`;
    content.innerHTML = `<canvas id="${canvasId}"></canvas>`;
    
    const ctx = document.getElementById(canvasId).getContext('2d');
    
    if (!chartReady || typeof Chart === 'undefined') {
        content.innerHTML = '<p class="text-muted">Графики временно недоступны</p>';
        return;
    }
    
    // Уничтожаем предыдущий график если есть
    if (charts[widgetId]) {
        charts[widgetId].destroy();
    }
    
    // Определяем источник данных в зависимости от метрики
    let chartData = {
        labels: [],
        datasets: []
    };
    
    let isHorizontal = false;
    
    if (data.config && data.config.metric === 'weekly_trend') {
        const metric = Array.isArray(data.data) ? data.data : [];
        
        chartData.labels = metric.map(item => item.day_short || item.day || '');
        chartData.datasets = [
            {
                label: 'Официальные',
                data: metric.map(item => item.official_count || 0),
                backgroundColor: 'rgba(0, 123, 255, 0.6)',
                borderColor: '#007bff',
                borderWidth: 1
            },
            {
                label: 'Студенты',
                data: metric.map(item => item.student_count || 0),
                backgroundColor: 'rgba(40, 167, 69, 0.6)',
                borderColor: '#28a745',
                borderWidth: 1
            }
        ];
    }
    else if (data.config && data.config.metric === 'duration_distribution') {
        const metric = Array.isArray(data.data) ? data.data : [];
        
        chartData.labels = metric.map(item => item.label || '');
        chartData.datasets = [
            {
                label: 'Визитов',
                data: metric.map(item => item.count || 0),
                backgroundColor: 'rgba(0, 123, 255, 0.6)',
                borderColor: '#007bff',
                borderWidth: 1
            }
        ];
        isHorizontal = true; // Горизонтальная гистограмма для длинных названий интервалов
    }
    
    charts[widgetId] = new Chart(ctx, {
        type: isHorizontal ? 'bar' : 'bar',
        data: chartData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: isHorizontal ? 'y' : 'x',
            plugins: {
                legend: {
                    display: chartData.datasets.length > 1
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

function renderCounterWidget(content, data) {
    const config = data.config || {};
    const metric = data.data || {};
    
    let value = 0;
    let label = 'Значение';
    
    // Определяем значение в зависимости от типа метрики
    if (config.metric === 'visitors_count') {
        value = metric.total_all || 0;
        label = 'Всего визитов';
    } else if (config.metric === 'active_visits') {
        value = metric.count || 0;
        label = 'В здании сейчас';
    } else if (config.metric === 'today_registrations') {
        value = metric.total_today || 0;
        label = 'Сегодня';
    } else if (config.metric === 'avg_visit_duration') {
        value = metric.avg_duration_minutes || 0;
        label = 'Минут в среднем';
    }
    
    const colorClass = config.color ? `color-${config.color}` : 'color-blue';
    
    content.innerHTML = `
        <div class="counter-widget">
            <div class="counter-value ${colorClass}">${value}</div>
            <div class="counter-label">${label}</div>
        </div>
    `;
}

function renderLineChartWidget(widgetId, content, data) {
    console.log(`renderLineChartWidget called for ${widgetId}:`, data);
    console.log(`Chart.js available: ${typeof Chart !== 'undefined'}, chartReady: ${chartReady}`);
    
    const canvasId = `chart-${widgetId}`;
    content.innerHTML = `<canvas id="${canvasId}"></canvas>`;
    
    const ctx = document.getElementById(canvasId).getContext('2d');
    
    if (!chartReady || typeof Chart === 'undefined') {
        console.error(`Chart.js not ready for widget ${widgetId}`);
        content.innerHTML = '<p class="text-muted">Графики временно недоступны</p>';
        return;
    }
    
    // Уничтожаем предыдущий график если есть
    if (charts[widgetId]) {
        console.log(`Destroying previous chart for widget ${widgetId}`);
        charts[widgetId].destroy();
    }
    
    // Определяем источник данных в зависимости от метрики
    let chartData = {
        labels: [],
        datasets: []
    };
    
    console.log(`Processing chart data for metric: ${data.config?.metric}`);
    
    if (data.config && data.config.metric === 'hourly_stats') {
        const metric = Array.isArray(data.data) ? data.data : (data.data?.hourly_data || []);
        console.log(`Hourly stats data:`, metric);
        
        chartData.labels = metric.map(item => item.hour || '');
        chartData.datasets = [{
            label: 'Визиты',
            data: metric.map(item => item.total || 0),
            borderColor: '#007bff',
            backgroundColor: 'rgba(0, 123, 255, 0.1)',
            tension: 0.4
        }];
    }
    else if (data.config && data.config.metric === 'visitor_type_comparison') {
        const metric = Array.isArray(data.data) ? data.data : [];
        console.log(`Visitor type comparison data:`, metric);
        
        chartData.labels = metric.map(item => item.date || '');
        chartData.datasets = [
            {
                label: 'Официальные',
                data: metric.map(item => item.official_count || 0),
                borderColor: '#007bff',
                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                tension: 0.4
            },
            {
                label: 'Студенты',
                data: metric.map(item => item.student_count || 0),
                borderColor: '#28a745',
                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                tension: 0.4
            }
        ];
    }
    
    charts[widgetId] = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: chartData.datasets.length > 1
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

function renderPieChartWidget(widgetId, content, data) {
    const canvasId = `chart-${widgetId}`;
    content.innerHTML = `<canvas id="${canvasId}"></canvas>`;
    
    const ctx = document.getElementById(canvasId).getContext('2d');
    const metric = Array.isArray(data.data) ? data.data : data.data || [];

    if (!chartReady || typeof Chart === 'undefined') {
        content.innerHTML = '<p class="text-muted">Диаграмма временно недоступна</p>';
        return;
    }
    
    // Уничтожаем предыдущий график если есть
    if (charts[widgetId]) {
        charts[widgetId].destroy();
    }
    
    // Определяем источник данных в зависимости от метрики
    let labels = [];
    let values = [];
    let bgColors = [
        '#007bff',
        '#28a745',
        '#fd7e14',
        '#6f42c1',
        '#dc3545',
        '#17a2b8',
        '#ffc107',
        '#6c757d'
    ];
    
    if (data.config && data.config.metric === 'department_stats') {
        // Берем топ-5 департаментов
        const topDepartments = metric.slice(0, 5);
        labels = topDepartments.map(item => item.department || '');
        values = topDepartments.map(item => item.total_visits || 0);
    }
    else if (data.config && data.config.metric === 'status_distribution') {
        // Берем распределение по статусам
        labels = metric.map(item => item.status_name || item.status || '');
        values = metric.map(item => item.total || 0);
    }
    else {
        // Обработка других типов данных
        if (Array.isArray(metric)) {
            for (const item of metric) {
                if (item.label) labels.push(item.label);
                else if (item.name) labels.push(item.name);
                else if (item.department) labels.push(item.department);
                else if (item.status) labels.push(item.status);
                
                if (item.value !== undefined) values.push(item.value);
                else if (item.count !== undefined) values.push(item.count);
                else if (item.total !== undefined) values.push(item.total);
            }
        }
    }
    
    charts[widgetId] = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: bgColors
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    });
}

function renderActivityFeedWidget(content, data) {
    // data.data может быть массивом событий или объектом с recent_events
    let events = [];
    if (Array.isArray(data.data)) {
        events = data.data;
    } else if (data.data && Array.isArray(data.data.recent_events)) {
        events = data.data.recent_events;
    }
    console.log('Activity feed events:', events);
    
    if (events.length === 0) {
        content.innerHTML = '<p class="text-muted text-center">Нет событий</p>';
        return;
    }
    
    let html = '<div class="activity-feed">';
    
    events.forEach(event => {
        const iconClass = getEventIconClass(event.type);
        const timeAgo = getTimeAgo(event.timestamp);
        
        html += `
            <div class="activity-item">
                <div class="activity-icon ${iconClass}">
                    <i class="fas ${getEventIcon(event.type)}"></i>
                </div>
                <div class="activity-content">
                    <div class="activity-title">${event.title}</div>
                    <div class="activity-message">${event.message}</div>
                    <div class="activity-time">${timeAgo}</div>
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    content.innerHTML = html;
}

function renderTableWidget(content, data) {
    const visits = (data.data && Array.isArray(data.data.visits)) ? data.data.visits : [];
    console.log('Table visits:', visits);
    
    console.log('Rendering table widget with visits:', visits);
    
    if (visits.length === 0) {
        content.innerHTML = '<p class="text-muted text-center">Нет активных визитов</p>';
        return;
    }
    
    let html = `
        <div class="table-widget">
            <table class="table table-striped" aria-live="polite">
                <thead>
                    <tr>
                        <th scope="col">Гость</th>
                        <th scope="col">Департамент</th>
                        <th scope="col">Время входа</th>
                        <th scope="col">Длительность</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    visits.forEach(visit => {
        const entryTime = visit.entry_time ? new Date(visit.entry_time).toLocaleTimeString() : '-';
        const duration = visit.duration_minutes ? `${visit.duration_minutes} мин` : '-';
        
        html += `
            <tr>
                <td>
                    <span class="status-indicator status-active" aria-hidden="true"></span>
                    ${visit.guest_name}
                </td>
                <td>${visit.department}</td>
                <td>${entryTime}</td>
                <td>${duration}</td>
            </tr>
        `;
    });
    
    html += '</tbody></table></div>';
    content.innerHTML = html;
}

function showWidgetError(content, message) {
    content.innerHTML = `
        <div class="text-center py-3">
            <i class="fas fa-exclamation-triangle text-warning mb-2" style="font-size: 24px;"></i>
            <p class="text-muted mb-0">${message}</p>
        </div>
    `;
}

// showToast function
function showToast(title, message, type = 'info') {
    console.log(`Toast: ${type} - ${title}: ${message}`);
    
    const toastRoot = document.getElementById('toast-root');
    if (!toastRoot) {
        console.warn('Toast container not found, creating fallback');
        const div = document.createElement('div');
        div.id = 'toast-root';
        div.className = 'toast-container';
        document.body.appendChild(div);
    }
    
    const container = document.getElementById('toast-root') || document.body;
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    
    toast.innerHTML = `
        <div class="title">${title || 'Уведомление'}</div>
        <div class="msg">${message || ''}</div>
    `;
    
    container.appendChild(toast);
    
    setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
    }, 5000);
    
    return toast;
}

// Функция refreshAllWidgets уже объявлена выше

function getEventIconClass(eventType) {
    switch (eventType) {
        case 'visit_created': return 'visit-created';
        case 'visit_checked_in': return 'visit-checked-in';
        case 'visit_checked_out': return 'visit-checked-out';
        case 'security_alert': return 'security-alert';
        default: return 'visit-created';
    }
}

function getEventIcon(eventType) {
    switch (eventType) {
        case 'visit_created': return 'fa-plus';
        case 'visit_checked_in': return 'fa-sign-in-alt';
        case 'visit_checked_out': return 'fa-sign-out-alt';
        case 'security_alert': return 'fa-exclamation-triangle';
        default: return 'fa-info';
    }
}

function getTimeAgo(timestamp) {
    const now = new Date();
    const time = new Date(timestamp);
    const diffMs = now - time;
    const diffMins = Math.floor(diffMs / 60000);
    
    if (diffMins < 1) return 'только что';
    if (diffMins < 60) return `${diffMins} мин назад`;
    
    const diffHours = Math.floor(diffMins / 60);
    if (diffHours < 24) return `${diffHours} ч назад`;
    
    const diffDays = Math.floor(diffHours / 24);
    return `${diffDays} дн назад`;
}

// Очистка интервалов при уходе со страницы
window.addEventListener('beforeunload', function() {
    Object.values(refreshIntervals).forEach(interval => {
        clearInterval(interval);
    });
    
    Object.values(charts).forEach(chart => {
        chart.destroy();
    });
});

// Функция refreshAllWidgets уже доступна глобально
</script>
{% endblock %}
